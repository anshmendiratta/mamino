diff --git a/.gitignore b/.gitignore
index 43a0eb7..dfc74fb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,3 +12,4 @@ src.exe
 vid.mp4
 vid.mov
 imgui.ini
+ols.json
diff --git a/src/main.odin b/src/main.odin
index 4583250..9eee6dc 100644
--- a/src/main.odin
+++ b/src/main.odin
@@ -58,7 +58,7 @@ main :: proc() {
 		render.mamino_init_imgui(window)
 		render.highlighted_debug_object_id = 0
 	}
-	
+
 	program_id, uniforms := render.mamino_init_gl()
 	when MAMINO_EXPORT_VIDEO {
 		sequencing.mamino_frame_capture_init()
@@ -68,17 +68,12 @@ main :: proc() {
 
 	cube := objects.create_cube()
 	render.add_object(&scene, &cube)
-	objects.add_key_frame(&cube, 
-		scale = objects.Scale {
-			1., 2., 1.,
-		},
-	)
-	objects.add_key_frame(&cube, 
-		orientation = objects.Orientation {
-			norm = {1., 0., 0.,}, 
-			angle = glm.radians(f32(45.))
-		},
+	objects.add_key_frame(&cube, scale = objects.Scale{1., 2., 1.})
+	objects.add_key_frame(
+		&cube,
+		orientation = objects.Orientation{norm = {1., 0., 0.}, angle = glm.radians(f32(45.))},
 	)
+	objects.lock(&cube)
 
 	// cube1 := objects.create_cube(
 	// 	center = {1., 1., 1.},
@@ -150,7 +145,6 @@ main :: proc() {
 	}
 
 	for (!glfw.WindowShouldClose(window) && render.running) {
-
 		// NOTE(Jaran): temporary "public" API to modify keyframes
 		objects.set_current_key_frame(&cube, render.current_key_frame)
 
@@ -201,11 +195,11 @@ main :: proc() {
 	}
 
 	video_options: sequencing.VideoOptions = {
-			resolution = {1920, 1080},
-			framerate  = 180,
-			encoding   = "libx264",
-			out_name   = "vid.h264",
-		}
+		resolution = {1920, 1080},
+		framerate  = 180,
+		encoding   = "libx264",
+		out_name   = "vid.h264",
+	}
 	if valid_vo := sequencing.validate_video_options(video_options); !valid_vo {
 		fmt.eprintln("Incorrect export video options.")
 		return
diff --git a/src/objects/cube.odin b/src/objects/cube.odin
index 141fce1..feebdfb 100644
--- a/src/objects/cube.odin
+++ b/src/objects/cube.odin
@@ -5,20 +5,26 @@ import "core:mem"
 
 Cube :: struct {
 	// Geometric center.
-	id:          ObjectID,
-	center:      glm.vec3,
-	key_frames: [dynamic]KeyFrame,
+	id:                ObjectID,
+	center:            glm.vec3,
+	key_frames:        [dynamic]KeyFrame,
 	current_key_frame: uint,
+	_locked:           bool,
 }
 
-create_cube :: proc(center: glm.vec3 = {0., 0., 0.}, starting_scale: Scale = {1., 1., 1.}, starting_orientation: Orientation = {norm = {1., 0., 0.,}, angle = 0.}) -> Object {
+create_cube :: proc(
+	center: glm.vec3 = {0., 0., 0.},
+	starting_scale: Scale = {1., 1., 1.},
+	starting_orientation: Orientation = {norm = {1., 0., 0.}, angle = 0.},
+) -> Object {
 	key_frames := make([dynamic]KeyFrame)
-	append(&key_frames, KeyFrame { scale = starting_scale, orientation = starting_orientation })
+	append(&key_frames, KeyFrame{scale = starting_scale, orientation = starting_orientation})
 	cube := Cube {
-		id = current_object_id,
-		center = center,
-		key_frames = key_frames,
+		id                = current_object_id,
+		center            = center,
+		key_frames        = key_frames,
 		current_key_frame = 0,
+		_locked           = false,
 	}
 
 	current_object_id += 1
@@ -26,13 +32,20 @@ create_cube :: proc(center: glm.vec3 = {0., 0., 0.}, starting_scale: Scale = {1.
 	return cube
 }
 
+lock :: proc(cube: ^Cube) {
+	cube._locked = true
+	// Populate the keyframes.:hs
+	//  f
+
+}
+
 get_cube_vertices :: proc(cube: Cube) -> (vertices: []Vertex) {
 	vertices = make([]Vertex, len(cube_vertices), context.temp_allocator)
 	copy(vertices, cube_vertices)
-	
+
 	scale := cube.key_frames[cube.current_key_frame].scale
 	orientation := cube.key_frames[cube.current_key_frame].orientation
-	
+
 	for &vertex in vertices {
 		vertex.position.x *= scale.x
 		vertex.position.y *= scale.y
@@ -66,12 +79,9 @@ get_cube_normals_coordinates :: proc(cube: Cube) -> (normals: []Vertex) {
 	rotated_z_axis: glm.vec3 = (rotation_matrix * standard_z_axis).xyz
 
 	// Addition of a glm.vec3 so the endpoints stick above the faces by a defined amount.
-	rotated_x_normal: glm.vec3 =
-		(rotation_matrix * standard_x_axis).xyz * scale.x + rotated_x_axis
-	rotated_y_normal: glm.vec3 =
-		(rotation_matrix * standard_y_axis).xyz * scale.y + rotated_y_axis
-	rotated_z_normal: glm.vec3 =
-		(rotation_matrix * standard_z_axis).xyz * scale.z + rotated_z_axis
+	rotated_x_normal: glm.vec3 = (rotation_matrix * standard_x_axis).xyz * scale.x + rotated_x_axis
+	rotated_y_normal: glm.vec3 = (rotation_matrix * standard_y_axis).xyz * scale.y + rotated_y_axis
+	rotated_z_normal: glm.vec3 = (rotation_matrix * standard_z_axis).xyz * scale.z + rotated_z_axis
 
 	x_normal_color := x_axis_color
 	y_normal_color := y_axis_color
diff --git a/src/objects/generic_data.odin b/src/objects/generic_data.odin
index 85f3f50..ba7fab8 100644
--- a/src/objects/generic_data.odin
+++ b/src/objects/generic_data.odin
@@ -24,8 +24,13 @@ Orientation :: struct {
 }
 
 KeyFrame :: struct {
-	scale: Scale,
-	orientation: Orientation,
+	scale:        Scale,
+	orientation:  Orientation,
+	interpolatio: KeyFrameInteprolation,
+}
+
+KeyFrameInteprolation :: enum {
+	Linear,
 }
 
 Object :: union {
@@ -43,20 +48,32 @@ current_object_id: ObjectID = 0
 
 set_current_key_frame :: proc(object: ^Object, frame_index: uint) {
 	#partial switch &generic_object in object {
-		case Cube:
-			generic_object.current_key_frame = frame_index % len(generic_object.key_frames)
-		case:
-			return
+	case Cube:
+		generic_object.current_key_frame = frame_index % len(generic_object.key_frames)
+	case:
+		return
 	}
 }
 
-add_key_frame :: proc(object: ^Object, scale: Maybe(Scale) = nil, orientation: Maybe(Orientation) = nil) {
+add_key_frame :: proc(
+	object: ^Object,
+	scale: Maybe(Scale) = nil,
+	orientation: Maybe(Orientation) = nil,
+	interpolation: KeyFrameInterpolation = KeyFrameInterpolation.Linear,
+) {
 	#partial switch &generic_object in object {
-		case Cube:
-			last_index := len(generic_object.key_frames) - 1
-			append(&generic_object.key_frames, KeyFrame { scale = scale.? or_else generic_object.key_frames[last_index].scale, orientation = orientation.? or_else generic_object.key_frames[last_index].orientation })
-		case:
-			return
+	case Cube:
+		last_index := len(generic_object.key_frames) - 1
+		append(
+			&generic_object.key_frames,
+			KeyFrame {
+				scale = scale.? or_else generic_object.key_frames[last_index].scale,
+				orientation = orientation.? or_else generic_object.key_frames[last_index].orientation,
+				interpolation = interpolation,
+			},
+		)
+	case:
+		return
 	}
 }
 
